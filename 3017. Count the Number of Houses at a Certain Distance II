class Solution(object):
    def countOfPairs(self, n, x, y):
        """
        :type n: int
        :type x: int
        :type y: int
        :rtype: List[int]
        """
        if x > y:
            x, y = y, x

        ring_len = y - x + 1          # length of the segment [x, y]
        left_line_len = x - 1         # houses on the left of x
        right_line_len = n - y        # houses on the right of y

        def both_in_ring(ring_len):
            # both houses are inside [x, y]
            res = [0] * n
            # distances 1 .. floor((ring_len-1)/2)
            for k in range(1, (ring_len - 1) // 2 + 1):
                res[k - 1] += ring_len
            # if ring_len even, middle distance has only ring_len/2 unordered pairs
            if ring_len % 2 == 0:
                res[ring_len // 2 - 1] += ring_len // 2
            return res

        def both_in_same_line(line_len):
            # both houses are either in [1, x-1] or in [y+1, n]
            res = [0] * n
            # pure path counts: for distance k there are (line_len - k) unordered pairs
            for k in range(1, line_len + 1):
                res[k - 1] += line_len - k
            return res

        def line_to_ring(line_len, ring_len):
            # one in line ([1, x-1] or [y+1, n]), one in ring [x, y]
            res = [0] * n
            # total distance k ranges up to line_len + ring_len
            for k in range(1, line_len + ring_len + 1):
                # choose how much of the distance is inside the ring
                max_in_ring = min(k - 1, ring_len // 2)
                min_in_ring = max(0, k - line_len)
                if min_in_ring <= max_in_ring:
                    # each ring distance d in [min_in_ring, max_in_ring]
                    # contributes 2 unordered pairs (two directions around the ring)
                    res[k - 1] += (max_in_ring - min_in_ring + 1) * 2
                    if min_in_ring == 0:
                        # no split when ring contribution is 0
                        res[k - 1] -= 1
                    if max_in_ring * 2 == ring_len:
                        # symmetric middle point counted once, not twice
                        res[k - 1] -= 1
            return res

        def line_to_line(left_len, right_len):
            # one house in left line [1, x-1], the other in right line [y+1, n]
            res = [0] * n
            # total distance k up to left_len + right_len + 2 (crossing the ring edge)
            for k in range(1, left_len + right_len + 2 + 1):
                # choose how many edges used on the left side
                # need at least 1 edge on right, and (x < y) extra edge for the shortcut
                extra = 1 if x < y else 0
                max_in_left = min(left_len, k - 1 - extra)
                min_in_left = max(1, k - right_len - extra)
                if min_in_left <= max_in_left:
                    res[k - 1] += max_in_left - min_in_left + 1
            return res

        # accumulate contributions for unordered pairs
        ans = [0] * n
        # inside ring
        tmp = both_in_ring(ring_len)
        for i in range(n):
            ans[i] += tmp[i]
        # both in left or both in right
        tmp = both_in_same_line(left_line_len)
        for i in range(n):
            ans[i] += tmp[i]
        tmp = both_in_same_line(right_line_len)
        for i in range(n):
            ans[i] += tmp[i]
        # one in line, one in ring (left side)
        tmp = line_to_ring(left_line_len, ring_len)
        for i in range(n):
            ans[i] += tmp[i]
        # one in line, one in ring (right side)
        tmp = line_to_ring(right_line_len, ring_len)
        for i in range(n):
            ans[i] += tmp[i]
        # one in left line, one in right line
        tmp = line_to_line(left_line_len, right_line_len)
        for i in range(n):
            ans[i] += tmp[i]

        # convert unordered pair counts to ordered: multiply by 2
        return [v * 2 for v in ans]
